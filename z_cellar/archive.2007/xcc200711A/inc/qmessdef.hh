// -*- C++ -*-
 
#ifndef XM_QMESSDEF_HH_
 
//
// Automatically generated by GENMSGINC
//
// Configuration: XCC,SYS,XMPY
// Option XCC root = /opt/xmopts/xcc
// Option SYS root = /opt/xmidas/xm
// Option XMPY root = /opt/xmopts/xmpy
 
#include <queue.h>
 
struct mqh_MSGLOG : public MQ_HEADER {
  mqh_MSGLOG ()
  {
    nslots = 34;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "MSGLOG";
    ntype = 16;
    types = "LS[24]S[40]S[80]";
  }
};
 
struct MQD_MSGLOG {
  int_4 severity;
  fstring<24> date_time;
  fstring<40> source;
  fstring<80> text;
};
 
struct mqh_XMSG : public MQ_HEADER {
  mqh_XMSG ()
  {
    nslots = 31;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "XMSG";
    ntype = 16;
    types = "LS[24]S[16]S[80]";
  }
};
 
struct MQD_XMSG {
  int_4 severity;
  fstring<24> date_time;
  fstring<16> source;
  fstring<80> text;
};
 
struct mqh_TITLE : public MQ_HEADER {
  mqh_TITLE ()
  {
    nslots = 20;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "TITLE";
    ntype = 5;
    types = "S[40]";
  }
};
 
struct MQD_TITLE {
  fstring<40> text;
};
 
struct mqh_MSGMASK : public MQ_HEADER {
  mqh_MSGMASK ()
  {
    nslots = 5;
    type = 'L';
    nhslots = 4;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "MSGMASK";
  }
};
 
struct MQD_MSGMASK {
  int_4 mask;
};
 
struct mqh_MSGMASKINFO : public MQ_HEADER {
  int_4&	msgid;  // .info field alias
  mqh_MSGMASKINFO () :
    msgid(info)
  {
    nslots = 5;
    type = 'L';
    nhslots = 4;
    ndata = 1;
    msgid = 0;
    mode = 0;
    name = "=MSGMASK";
  }
};
 
struct MQD_MSGMASKINFO {
  int_4 mask;
};
 
struct mqh_SET : public MQ_HEADER {
  int_4&	value;  // .info field alias
  mqh_SET () :
    value(info)
  {
    nslots = 5;
    type = 'A';
    nhslots = 4;
    ndata = 1;
    value = 0;
    mode = 0;
    name = "SET";
  }
};
 
struct MQD_SET {
  fstring<8> object;
};
 
struct mqh_SETL : public MQ_HEADER {
  mqh_SETL ()
  {
    nslots = 17;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "SETL";
    ntype = 3;
    types = "A2L";
  }
};
 
struct MQD_SETL {
  fstring<8> object;
  int_4 value;
  int_4 value2;
};
 
struct mqh_SETD : public MQ_HEADER {
  mqh_SETD ()
  {
    nslots = 17;
    type = 'H';
    nhslots = 15;
    ndata = 2;
    info = 0;
    mode = 0;
    name = "SETD";
    ntype = 2;
    types = "AD";
  }
};
 
struct MQD_SETD {
  fstring<8> object;
  real_8 value;
};
 
struct mqh_QUERY : public MQ_HEADER {
  mqh_QUERY ()
  {
    nslots = 5;
    type = 'A';
    nhslots = 4;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "QUERY";
  }
};
 
struct MQD_QUERY {
  fstring<8> object;
};
 
struct mqh_EXIT : public MQ_HEADER {
  mqh_EXIT ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "EXIT";
  }
};
 
 
struct mqh_EXITINFO : public MQ_HEADER {
  mqh_EXITINFO ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "=EXIT";
  }
};
 
 
struct mqh_REREAD : public MQ_HEADER {
  mqh_REREAD ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "REREAD";
  }
};
 
 
struct mqh_REFRESH : public MQ_HEADER {
  mqh_REFRESH ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "REFRESH";
  }
};
 
 
struct mqh_COLOR : public MQ_HEADER {
  int_4&	colorid;  // .info field alias
  mqh_COLOR () :
    colorid(info)
  {
    nslots = 5;
    type = 'I';
    nhslots = 4;
    ndata = 4;
    colorid = 0;
    mode = 0;
    name = "COLOR";
  }
};
 
struct MQD_COLOR {
  int_2 position;
  int_2 red;
  int_2 green;
  int_2 blue;
};
 
struct mqh_COLORINFO : public MQ_HEADER {
  int_4&	colorid;  // .info field alias
  mqh_COLORINFO () :
    colorid(info)
  {
    nslots = 5;
    type = 'I';
    nhslots = 4;
    ndata = 4;
    colorid = 0;
    mode = 0;
    name = "=COLOR";
  }
};
 
struct MQD_COLORINFO {
  int_2 position;
  int_2 red;
  int_2 green;
  int_2 blue;
};
 
struct mqh_COLORMAP : public MQ_HEADER {
  int_4&	colormapid;  // .info field alias
  mqh_COLORMAP () :
    colormapid(info)
  {
    nslots = 11;
    type = 'I';
    nhslots = 4;
    ndata = 28;
    colormapid = 0;
    mode = 0;
    name = "COLORMAP";
  }
};
 
struct MQD_COLORMAP {
  int_2 position1;
  int_2 red1;
  int_2 green1;
  int_2 blue1;
  int_2 position2;
  int_2 red2;
  int_2 green2;
  int_2 blue2;
  int_2 position3;
  int_2 red3;
  int_2 green3;
  int_2 blue3;
  int_2 position4;
  int_2 red4;
  int_2 green4;
  int_2 blue4;
  int_2 position5;
  int_2 red5;
  int_2 green5;
  int_2 blue5;
  int_2 position6;
  int_2 red6;
  int_2 green6;
  int_2 blue6;
  int_2 position7;
  int_2 red7;
  int_2 green7;
  int_2 blue7;
};
 
struct mqh_COLORMAPINFO : public MQ_HEADER {
  int_4&	colormapid;  // .info field alias
  mqh_COLORMAPINFO () :
    colormapid(info)
  {
    nslots = 11;
    type = 'I';
    nhslots = 4;
    ndata = 28;
    colormapid = 0;
    mode = 0;
    name = "=COLORMA";
  }
};
 
struct MQD_COLORMAPINFO {
  int_2 position1;
  int_2 red1;
  int_2 green1;
  int_2 blue1;
  int_2 position2;
  int_2 red2;
  int_2 green2;
  int_2 blue2;
  int_2 position3;
  int_2 red3;
  int_2 green3;
  int_2 blue3;
  int_2 position4;
  int_2 red4;
  int_2 green4;
  int_2 blue4;
  int_2 position5;
  int_2 red5;
  int_2 green5;
  int_2 blue5;
  int_2 position6;
  int_2 red6;
  int_2 green6;
  int_2 blue6;
  int_2 position7;
  int_2 red7;
  int_2 green7;
  int_2 blue7;
};
 
struct mqh_TRACE : public MQ_HEADER {
  int_4&	layer;  // .info field alias
  mqh_TRACE () :
    layer(info)
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    layer = 0;
    mode = 0;
    name = "TRACE";
    ntype = 5;
    types = "2LA2L";
  }
};
 
struct MQD_TRACE {
  int_4 linetype;
  int_4 thick;
  fstring<8> symbol;
  int_4 radius;
  int_4 color;
};
 
struct mqh_OVERLAY : public MQ_HEADER {
  int_4&	layer;  // .info field alias
  mqh_OVERLAY () :
    layer(info)
  {
    nslots = 25;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    layer = 0;
    mode = 0;
    name = "OVERLAY";
    ntype = 5;
    types = "S[80]";
  }
};
 
struct MQD_OVERLAY {
  fstring<80> text;
};
 
struct mqh_DEOVERLAY : public MQ_HEADER {
  int_4&	layer;  // .info field alias
  mqh_DEOVERLAY () :
    layer(info)
  {
    nslots = 25;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    layer = 0;
    mode = 0;
    name = "DEOVERLA";
    ntype = 5;
    types = "S[80]";
  }
};
 
struct MQD_DEOVERLAY {
  fstring<80> text;
};
 
struct mqh_TRIM : public MQ_HEADER {
  int_4&	flag;  // .info field alias
  mqh_TRIM () :
    flag(info)
  {
    nslots = 6;
    type = 'D';
    nhslots = 4;
    ndata = 2;
    flag = 0;
    mode = 0;
    name = "TRIM";
  }
};
 
struct MQD_TRIM {
  real_8 x1;
  real_8 x2;
};
 
struct mqh_CXMODE : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_CXMODE () :
    level(info)
  {
    nslots = 5;
    type = 'A';
    nhslots = 4;
    ndata = 1;
    level = 0;
    mode = 0;
    name = "CXMODE";
  }
};
 
struct MQD_CXMODE {
  fstring<8> mode;
};
 
struct mqh_CXMODEINFO : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_CXMODEINFO () :
    level(info)
  {
    nslots = 5;
    type = 'A';
    nhslots = 4;
    ndata = 1;
    level = 0;
    mode = 0;
    name = "=CXMODE";
  }
};
 
struct MQD_CXMODEINFO {
  fstring<8> mode;
};
 
struct mqh_ZOOM : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_ZOOM () :
    level(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    level = 0;
    mode = 0;
    name = "ZOOM";
  }
};
 
struct MQD_ZOOM {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_ZOOMINFO : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_ZOOMINFO () :
    level(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    level = 0;
    mode = 0;
    name = "=ZOOM";
  }
};
 
struct MQD_ZOOMINFO {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_UNZOOM : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_UNZOOM () :
    level(info)
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    level = 0;
    mode = 0;
    name = "UNZOOM";
  }
};
 
 
struct mqh_UNZOOMINFO : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_UNZOOMINFO () :
    level(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    level = 0;
    mode = 0;
    name = "=UNZOOM";
  }
};
 
struct MQD_UNZOOMINFO {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_PAN : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_PAN () :
    level(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    level = 0;
    mode = 0;
    name = "PAN";
  }
};
 
struct MQD_PAN {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_PANRANGE : public MQ_HEADER {
  mqh_PANRANGE ()
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "PANRANGE";
  }
};
 
struct MQD_PANRANGE {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_PANINFO : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_PANINFO () :
    level(info)
  {
    nslots = 21;
    type = 'H';
    nhslots = 15;
    ndata = 7;
    level = 0;
    mode = 0;
    name = "=PAN";
    ntype = 5;
    types = "4D2LA";
  }
};
 
struct MQD_PANINFO {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
  int_4 xunits;
  int_4 yunits;
  fstring<8> cxmode;
};
 
struct mqh_PLOTINFO : public MQ_HEADER {
  int_4&	level;  // .info field alias
  mqh_PLOTINFO () :
    level(info)
  {
    nslots = 23;
    type = 'H';
    nhslots = 15;
    ndata = 10;
    level = 0;
    mode = 0;
    name = "=PLOT";
    ntype = 8;
    types = "4D2LA2LA";
  }
};
 
struct MQD_PLOTINFO {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
  int_4 xunits;
  int_4 yunits;
  fstring<8> cxmode;
  int_4 xframe;
  int_4 yframe;
  fstring<8> primname;
};
 
struct mqh_MARKINFO : public MQ_HEADER {
  mqh_MARKINFO ()
  {
    nslots = 7;
    type = 'D';
    nhslots = 4;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "=MARK";
  }
};
 
struct MQD_MARKINFO {
  real_8 x;
  real_8 y;
  real_8 z;
};
 
struct mqh_MARK : public MQ_HEADER {
  mqh_MARK ()
  {
    nslots = 7;
    type = 'D';
    nhslots = 4;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "MARK";
  }
};
 
struct MQD_MARK {
  real_8 x;
  real_8 y;
  real_8 z;
};
 
struct mqh_ANNOTATE : public MQ_HEADER {
  int_4&	anntid;  // .info field alias
  mqh_ANNOTATE () :
    anntid(info)
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    anntid = 0;
    mode = 0;
    name = "ANNOTATE";
    ntype = 8;
    types = "AS[80]2L";
  }
};
 
struct MQD_ANNOTATE {
  fstring<8> func;
  fstring<80> text;
  int_4 arg1;
  int_4 arg2;
};
 
struct mqh_BOXINFO : public MQ_HEADER {
  int_4&	boxid;  // .info field alias
  mqh_BOXINFO () :
    boxid(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    boxid = 0;
    mode = 0;
    name = "=BOX";
  }
};
 
struct MQD_BOXINFO {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_BOXADD : public MQ_HEADER {
  int_4&	boxid;  // .info field alias
  mqh_BOXADD () :
    boxid(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    boxid = 0;
    mode = 0;
    name = "BOXADD";
  }
};
 
struct MQD_BOXADD {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_BOXDELETE : public MQ_HEADER {
  int_4&	boxid;  // .info field alias
  mqh_BOXDELETE () :
    boxid(info)
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    boxid = 0;
    mode = 0;
    name = "BOXDELET";
  }
};
 
 
struct mqh_BOXALTER : public MQ_HEADER {
  int_4&	boxid;  // .info field alias
  mqh_BOXALTER () :
    boxid(info)
  {
    nslots = 8;
    type = 'D';
    nhslots = 4;
    ndata = 4;
    boxid = 0;
    mode = 0;
    name = "BOXALTER";
  }
};
 
struct MQD_BOXALTER {
  real_8 xmin;
  real_8 xmax;
  real_8 ymin;
  real_8 ymax;
};
 
struct mqh_POINTINFO : public MQ_HEADER {
  int_4&	pointid;  // .info field alias
  mqh_POINTINFO () :
    pointid(info)
  {
    nslots = 6;
    type = 'D';
    nhslots = 4;
    ndata = 2;
    pointid = 0;
    mode = 0;
    name = "=POINT";
  }
};
 
struct MQD_POINTINFO {
  real_8 x;
  real_8 y;
};
 
struct mqh_POINTADD : public MQ_HEADER {
  int_4&	pointid;  // .info field alias
  mqh_POINTADD () :
    pointid(info)
  {
    nslots = 6;
    type = 'D';
    nhslots = 4;
    ndata = 2;
    pointid = 0;
    mode = 0;
    name = "POINTADD";
  }
};
 
struct MQD_POINTADD {
  real_8 x;
  real_8 y;
};
 
struct mqh_POINTDELETE : public MQ_HEADER {
  int_4&	pointid;  // .info field alias
  mqh_POINTDELETE () :
    pointid(info)
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    pointid = 0;
    mode = 0;
    name = "POINTDEL";
  }
};
 
 
struct mqh_POINTALTER : public MQ_HEADER {
  int_4&	pointid;  // .info field alias
  mqh_POINTALTER () :
    pointid(info)
  {
    nslots = 6;
    type = 'D';
    nhslots = 4;
    ndata = 2;
    pointid = 0;
    mode = 0;
    name = "POINTALT";
  }
};
 
struct MQD_POINTALTER {
  real_8 x;
  real_8 y;
};
 
struct mqh_XCNTRL : public MQ_HEADER {
  int_4&	awid;  // .info field alias
  mqh_XCNTRL () :
    awid(info)
  {
    nslots = 5;
    type = 'D';
    nhslots = 4;
    ndata = 1;
    awid = 0;
    mode = 0;
    name = "XCNTRL";
  }
};
 
struct MQD_XCNTRL {
  real_8 value;
};
 
struct mqh_XCTAG : public MQ_HEADER {
  int_4&	rwid;  // .info field alias
  mqh_XCTAG () :
    rwid(info)
  {
    nslots = 5;
    type = 'D';
    nhslots = 4;
    ndata = 1;
    rwid = 0;
    mode = 0;
    name = "XCTAG";
  }
};
 
struct MQD_XCTAG {
  real_8 value;
};
 
struct mqh_XTODO : public MQ_HEADER {
  mqh_XTODO ()
  {
    nslots = 5;
    type = 'D';
    nhslots = 4;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "XTODO";
  }
};
 
struct MQD_XTODO {
  real_8 amount;
};
 
struct mqh_HARDCOPY : public MQ_HEADER {
  int_4&	flag;  // .info field alias
  mqh_HARDCOPY () :
    flag(info)
  {
    nslots = 25;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    flag = 0;
    mode = 0;
    name = "HARDCOPY";
    ntype = 5;
    types = "S[80]";
  }
};
 
struct MQD_HARDCOPY {
  fstring<80> file;
};
 
struct mqh_COMMAND : public MQ_HEADER {
  int_4&	channel;  // .info field alias
  mqh_COMMAND () :
    channel(info)
  {
    nslots = 20;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    channel = 0;
    mode = 0;
    name = "COMMAND";
    ntype = 5;
    types = "S[40]";
  }
};
 
struct MQD_COMMAND {
  fstring<40> command;
};
 
struct mqh_COMMANDR : public MQ_HEADER {
  int_4&	channel;  // .info field alias
  mqh_COMMANDR () :
    channel(info)
  {
    nslots = 20;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    channel = 0;
    mode = 0;
    name = "COMMANDR";
    ntype = 5;
    types = "S[40]";
  }
};
 
struct MQD_COMMANDR {
  fstring<40> command;
};
 
struct mqh_CREPLY : public MQ_HEADER {
  int_4&	status;  // .info field alias
  mqh_CREPLY () :
    status(info)
  {
    nslots = 25;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    status = 0;
    mode = 0;
    name = "CREPLY";
    ntype = 5;
    types = "S[80]";
  }
};
 
struct MQD_CREPLY {
  fstring<80> reply;
};
 
struct mqh_NEWFILE : public MQ_HEADER {
  int_4&	modify;  // .info field alias
  mqh_NEWFILE () :
    modify(info)
  {
    nslots = 26;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    modify = 0;
    mode = 0;
    name = "NEWFILE";
    ntype = 7;
    types = "S[80]2L";
  }
};
 
struct MQD_NEWFILE {
  fstring<80> filename;
  int_4 arg1;
  int_4 arg2;
};
 
struct mqh_NEWFILEINFO : public MQ_HEADER {
  int_4&	success;  // .info field alias
  mqh_NEWFILEINFO () :
    success(info)
  {
    nslots = 26;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    success = 0;
    mode = 0;
    name = "=NEWFILE";
    ntype = 7;
    types = "S[80]2L";
  }
};
 
struct MQD_NEWFILEINFO {
  fstring<80> filename;
  int_4 arg1;
  int_4 arg2;
};
 
struct mqh_MODIFYINFO : public MQ_HEADER {
  mqh_MODIFYINFO ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "=MODIFY";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_MODIFYINFO {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_MODIFY : public MQ_HEADER {
  mqh_MODIFY ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "MODIFY";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_MODIFY {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_SELECTINFO : public MQ_HEADER {
  mqh_SELECTINFO ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "=SELECT";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_SELECTINFO {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_SELECT : public MQ_HEADER {
  int_4&	pan;  // .info field alias
  mqh_SELECT () :
    pan(info)
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    pan = 0;
    mode = 0;
    name = "SELECT";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_SELECT {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_LOOKUPINFO : public MQ_HEADER {
  mqh_LOOKUPINFO ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "=LOOKUP";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_LOOKUPINFO {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_LOOKUP : public MQ_HEADER {
  mqh_LOOKUP ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "LOOKUP";
    ntype = 7;
    types = "D3LS[4]";
  }
};
 
struct MQD_LOOKUP {
  real_8 elemt;
  int_4 field;
  int_4 scalar;
  int_4 subelemt;
  fstring<4> name;
};
 
struct mqh_HLITADD : public MQ_HEADER {
  mqh_HLITADD ()
  {
    nslots = 20;
    type = 'H';
    nhslots = 15;
    ndata = 8;
    info = 0;
    mode = 0;
    name = "HLITADD";
    ntype = 8;
    types = "2LD2LD2L";
  }
};
 
struct MQD_HLITADD {
  int_4 id;
  int_4 color;
  real_8 elemtfrom;
  int_4 fieldfrom;
  int_4 scalarfrom;
  real_8 elemtto;
  int_4 fieldto;
  int_4 scalarto;
};
 
struct mqh_HLITMOD : public MQ_HEADER {
  int_4&	region;  // .info field alias
  mqh_HLITMOD () :
    region(info)
  {
    nslots = 20;
    type = 'H';
    nhslots = 15;
    ndata = 8;
    region = 0;
    mode = 0;
    name = "HLITMOD";
    ntype = 8;
    types = "2LD2LD2L";
  }
};
 
struct MQD_HLITMOD {
  int_4 id;
  int_4 color;
  real_8 elemtfrom;
  int_4 fieldfrom;
  int_4 scalarfrom;
  real_8 elemtto;
  int_4 fieldto;
  int_4 scalarto;
};
 
struct mqh_HLITDEL : public MQ_HEADER {
  int_4&	region;  // .info field alias
  mqh_HLITDEL () :
    region(info)
  {
    nslots = 5;
    type = 'L';
    nhslots = 4;
    ndata = 1;
    region = 0;
    mode = 0;
    name = "HLITDEL";
  }
};
 
struct MQD_HLITDEL {
  int_4 id;
};
 
struct mqh_FEDIT : public MQ_HEADER {
  int_4&	op;  // .info field alias
  mqh_FEDIT () :
    op(info)
  {
    nslots = 17;
    type = 'H';
    nhslots = 15;
    ndata = 2;
    op = 0;
    mode = 0;
    name = "FEDIT";
    ntype = 2;
    types = "DL";
  }
};
 
struct MQD_FEDIT {
  real_8 elemt;
  int_4 numelemts;
};
 
struct mqh_FEDITINFO : public MQ_HEADER {
  int_4&	op;  // .info field alias
  mqh_FEDITINFO () :
    op(info)
  {
    nslots = 17;
    type = 'H';
    nhslots = 15;
    ndata = 2;
    op = 0;
    mode = 0;
    name = "=FEDIT";
    ntype = 2;
    types = "DL";
  }
};
 
struct MQD_FEDITINFO {
  real_8 elemt;
  int_4 numelemts;
};
 
struct mqh_XTEXT : public MQ_HEADER {
  mqh_XTEXT ()
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "XTEXT";
    ntype = 5;
    types = "S[96]";
  }
};
 
struct MQD_XTEXT {
  fstring<96> text;
};
 
struct mqh_XTEXTA : public MQ_HEADER {
  mqh_XTEXTA ()
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "XTEXTA";
    ntype = 5;
    types = "S[96]";
  }
};
 
struct MQD_XTEXTA {
  fstring<96> text;
};
 
struct mqh_XTEXTROW : public MQ_HEADER {
  mqh_XTEXTROW ()
  {
    nslots = 28;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "XTEXTROW";
    ntype = 7;
    types = "2LS[96]";
  }
};
 
struct MQD_XTEXTROW {
  int_4 row;
  int_4 na;
  fstring<96> text;
};
 
struct mqh_XTEXTCLR : public MQ_HEADER {
  mqh_XTEXTCLR ()
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "XTEXTCLR";
    ntype = 5;
    types = "S[96]";
  }
};
 
struct MQD_XTEXTCLR {
  fstring<96> text;
};
 
struct mqh_XTEXTHDR : public MQ_HEADER {
  mqh_XTEXTHDR ()
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "XTEXTHDR";
    ntype = 5;
    types = "S[96]";
  }
};
 
struct MQD_XTEXTHDR {
  fstring<96> text;
};
 
struct mqh_XTCLEAR : public MQ_HEADER {
  mqh_XTCLEAR ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "XTCLEAR";
  }
};
 
 
struct mqh_XTXTRPOS : public MQ_HEADER {
  mqh_XTXTRPOS ()
  {
    nslots = 5;
    type = 'L';
    nhslots = 4;
    ndata = 2;
    info = 0;
    mode = 0;
    name = "XTXTRPOS";
  }
};
 
struct MQD_XTXTRPOS {
  int_4 row;
  int_4 position;
};
 
struct mqh_T5REC : public MQ_HEADER {
  int_4&	modmask;  // .info field alias
  mqh_T5REC () :
    modmask(info)
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 17;
    modmask = 0;
    mode = 0;
    name = "T5REC";
    ntype = 10;
    types = "2L3DA6DL4B";
  }
};
 
struct MQD_T5REC {
  int_4 layer;
  int_4 index;
  real_8 alt;
  real_8 lat;
  real_8 lon;
  fstring<8> name;
  real_8 azim;
  real_8 elev;
  real_8 roll;
  real_8 r;
  real_8 a;
  real_8 b;
  int_4 color;
  int_1 symbol;
  int_1 size;
  int_1 cone;
  int_1 invert;
};
 
struct mqh_T5TEXT : public MQ_HEADER {
  int_4&	modmask;  // .info field alias
  mqh_T5TEXT () :
    modmask(info)
  {
    nslots = 27;
    type = 'H';
    nhslots = 15;
    ndata = 12;
    modmask = 0;
    mode = 0;
    name = "T5TEXT";
    ntype = 13;
    types = "2L3DAS[48]L4B";
  }
};
 
struct MQD_T5TEXT {
  int_4 layer;
  int_4 index;
  real_8 alt;
  real_8 lat;
  real_8 lon;
  fstring<8> name;
  fstring<48> text;
  int_4 color;
  int_1 symbol;
  int_1 size;
  int_1 cone;
  int_1 invert;
};
 
struct mqh_T5LAYER : public MQ_HEADER {
  int_4&	layer;  // .info field alias
  mqh_T5LAYER () :
    layer(info)
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    layer = 0;
    mode = 0;
    name = "T5LAYER";
    ntype = 3;
    types = "A4L";
  }
};
 
struct MQD_T5LAYER {
  fstring<8> action;
  int_4 p1;
  int_4 p2;
  int_4 p3;
  int_4 p4;
};
 
struct mqh_ATMRTDAT : public MQ_HEADER {
  mqh_ATMRTDAT ()
  {
    nslots = 18;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "ATMRTDAT";
    ntype = 4;
    types = "2D2L";
  }
};
 
struct MQD_ATMRTDAT {
  real_8 time;
  real_8 y;
  int_4 colr;
  int_4 tnum;
};
 
struct mqh_ATMRTD8 : public MQ_HEADER {
  int_4&	num;  // .info field alias
  mqh_ATMRTD8 () :
    num(info)
  {
    nslots = 39;
    type = 'H';
    nhslots = 15;
    ndata = 32;
    num = 0;
    mode = 0;
    name = "ATMRTD8";
    ntype = 6;
    types = "16D16L";
  }
};
 
struct MQD_ATMRTD8 {
  real_8 time1;
  real_8 time2;
  real_8 time3;
  real_8 time4;
  real_8 time5;
  real_8 time6;
  real_8 time7;
  real_8 time8;
  real_8 y1;
  real_8 y2;
  real_8 y3;
  real_8 y4;
  real_8 y5;
  real_8 y6;
  real_8 y7;
  real_8 y8;
  int_4 tnum1;
  int_4 tnum2;
  int_4 tnum3;
  int_4 tnum4;
  int_4 tnum5;
  int_4 tnum6;
  int_4 tnum7;
  int_4 tnum8;
  int_4 colr1;
  int_4 colr2;
  int_4 colr3;
  int_4 colr4;
  int_4 colr5;
  int_4 colr6;
  int_4 colr7;
  int_4 colr8;
};
 
struct mqh_ATMRTD16 : public MQ_HEADER {
  int_4&	num;  // .info field alias
  mqh_ATMRTD16 () :
    num(info)
  {
    nslots = 63;
    type = 'H';
    nhslots = 15;
    ndata = 64;
    num = 0;
    mode = 0;
    name = "ATMRTD16";
    ntype = 12;
    types = "16D16L16D16L";
  }
};
 
struct MQD_ATMRTD16 {
  real_8 time1;
  real_8 time2;
  real_8 time3;
  real_8 time4;
  real_8 time5;
  real_8 time6;
  real_8 time7;
  real_8 time8;
  real_8 y1;
  real_8 y2;
  real_8 y3;
  real_8 y4;
  real_8 y5;
  real_8 y6;
  real_8 y7;
  real_8 y8;
  int_4 tnum1;
  int_4 tnum2;
  int_4 tnum3;
  int_4 tnum4;
  int_4 tnum5;
  int_4 tnum6;
  int_4 tnum7;
  int_4 tnum8;
  int_4 colr1;
  int_4 colr2;
  int_4 colr3;
  int_4 colr4;
  int_4 colr5;
  int_4 colr6;
  int_4 colr7;
  int_4 colr8;
  real_8 time9;
  real_8 time10;
  real_8 time11;
  real_8 time12;
  real_8 time13;
  real_8 time14;
  real_8 time15;
  real_8 time16;
  real_8 y9;
  real_8 y10;
  real_8 y11;
  real_8 y12;
  real_8 y13;
  real_8 y14;
  real_8 y15;
  real_8 y16;
  int_4 tnum9;
  int_4 tnum10;
  int_4 tnum11;
  int_4 tnum12;
  int_4 tnum13;
  int_4 tnum14;
  int_4 tnum15;
  int_4 tnum16;
  int_4 colr9;
  int_4 colr10;
  int_4 colr11;
  int_4 colr12;
  int_4 colr13;
  int_4 colr14;
  int_4 colr15;
  int_4 colr16;
};
 
struct mqh_ATMOVER : public MQ_HEADER {
  mqh_ATMOVER ()
  {
    nslots = 32;
    type = 'H';
    nhslots = 15;
    ndata = 7;
    info = 0;
    mode = 0;
    name = "ATMOVER";
    ntype = 13;
    types = "D4LS[80]S[32]";
  }
};
 
struct MQD_ATMOVER {
  real_8 connect;
  int_4 colr;
  int_4 refresh;
  int_4 mode;
  int_4 sect;
  fstring<80> name;
  fstring<32> dispname;
};
 
struct mqh_ATMDOVER : public MQ_HEADER {
  mqh_ATMDOVER ()
  {
    nslots = 26;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "ATMDOVER";
    ntype = 7;
    types = "2LS[80]";
  }
};
 
struct MQD_ATMDOVER {
  int_4 refresh;
  int_4 sect;
  fstring<80> name;
};
 
struct mqh_NEWTRACE : public MQ_HEADER {
  mqh_NEWTRACE ()
  {
    nslots = 29;
    type = 'H';
    nhslots = 15;
    ndata = 8;
    info = 0;
    mode = 0;
    name = "NEWTRACE";
    ntype = 8;
    types = "6LAS[80]";
  }
};
 
struct MQD_NEWTRACE {
  int_4 tnum;
  int_4 bufsize;
  int_4 mode;
  int_4 sect;
  int_4 size;
  int_4 colr;
  fstring<8> datatype;
  fstring<80> name;
};
 
struct mqh_DELTRACE : public MQ_HEADER {
  mqh_DELTRACE ()
  {
    nslots = 26;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "DELTRACE";
    ntype = 7;
    types = "2LS[80]";
  }
};
 
struct MQD_DELTRACE {
  int_4 tnum;
  int_4 refresh;
  fstring<80> name;
};
 
struct mqh_ICONIFY : public MQ_HEADER {
  mqh_ICONIFY ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "ICONIFY";
  }
};
 
 
struct mqh_DEICON : public MQ_HEADER {
  mqh_DEICON ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "DEICON";
  }
};
 
 
struct mqh_THRESH : public MQ_HEADER {
  mqh_THRESH ()
  {
    nslots = 19;
    type = 'H';
    nhslots = 15;
    ndata = 7;
    info = 0;
    mode = 0;
    name = "THRESH";
    ntype = 3;
    types = "D6L";
  }
};
 
struct MQD_THRESH {
  real_8 level;
  int_4 thick;
  int_4 sect;
  int_4 num;
  int_4 colr;
  int_4 refresh;
  int_4 dummy;
};
 
struct mqh_TSTATE : public MQ_HEADER {
  mqh_TSTATE ()
  {
    nslots = 6;
    type = 'L';
    nhslots = 4;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "TSTATE";
  }
};
 
struct MQD_TSTATE {
  int_4 sect;
  int_4 num;
  int_4 state;
  int_4 refresh;
};
 
struct mqh_YAXIS : public MQ_HEADER {
  mqh_YAXIS ()
  {
    nslots = 19;
    type = 'H';
    nhslots = 15;
    ndata = 6;
    info = 0;
    mode = 0;
    name = "YAXIS";
    ntype = 4;
    types = "2D4L";
  }
};
 
struct MQD_YAXIS {
  real_8 ymin;
  real_8 ymax;
  int_4 sect;
  int_4 ydiv;
  int_4 origin;
  int_4 dummy;
};
 
struct mqh_TRNAME : public MQ_HEADER {
  mqh_TRNAME ()
  {
    nslots = 26;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "TRNAME";
    ntype = 7;
    types = "2LS[80]";
  }
};
 
struct MQD_TRNAME {
  int_4 tnum;
  int_4 dummy;
  fstring<80> name;
};
 
struct mqh_TRNAME8 : public MQ_HEADER {
  int_4&	num;  // .info field alias
  mqh_TRNAME8 () :
    num(info)
  {
    nslots = 99;
    type = 'H';
    nhslots = 15;
    ndata = 16;
    num = 0;
    mode = 0;
    name = "TRNAME8";
    ntype = 8;
    types = "8L8S[80]";
  }
};
 
struct MQD_TRNAME8 {
  int_4 tnum1;
  int_4 tnum2;
  int_4 tnum3;
  int_4 tnum4;
  int_4 tnum5;
  int_4 tnum6;
  int_4 tnum7;
  int_4 tnum8;
  fstring<80> name1;
  fstring<80> name2;
  fstring<80> name3;
  fstring<80> name4;
  fstring<80> name5;
  fstring<80> name6;
  fstring<80> name7;
  fstring<80> name8;
};
 
struct mqh_TIMEADJ : public MQ_HEADER {
  mqh_TIMEADJ ()
  {
    nslots = 17;
    type = 'H';
    nhslots = 15;
    ndata = 5;
    info = 0;
    mode = 0;
    name = "TIMEADJ";
    ntype = 5;
    types = "F2I2L";
  }
};
 
struct MQD_TIMEADJ {
  real_4 adjust;
  int_2 sect;
  int_2 colr;
  int_4 refresh;
  int_4 dummy;
};
 
struct mqh_ATMDIFF : public MQ_HEADER {
  mqh_ATMDIFF ()
  {
    nslots = 5;
    type = 'F';
    nhslots = 4;
    ndata = 1;
    info = 0;
    mode = 0;
    name = "ATMDIFF";
  }
};
 
struct MQD_ATMDIFF {
  real_4 diff;
};
 
struct mqh_CLEAR : public MQ_HEADER {
  mqh_CLEAR ()
  {
    nslots = 4;
    type = ' ';
    nhslots = 4;
    ndata = 0;
    info = 0;
    mode = 0;
    name = "CLEAR";
  }
};
 
 
struct mqh_SETKEY : public MQ_HEADER {
  mqh_SETKEY ()
  {
    nslots = 30;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "SETKEY";
    ntype = 6;
    types = "3S[40]";
  }
};
 
struct MQD_SETKEY {
  fstring<40> addr;
  fstring<40> name;
  fstring<40> value;
};
 
struct mqh_ACKKEY : public MQ_HEADER {
  mqh_ACKKEY ()
  {
    nslots = 30;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "ACKKEY";
    ntype = 6;
    types = "3S[40]";
  }
};
 
struct MQD_ACKKEY {
  fstring<40> addr;
  fstring<40> name;
  fstring<40> value;
};
 
struct mqh_GETKEY : public MQ_HEADER {
  mqh_GETKEY ()
  {
    nslots = 30;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "GETKEY";
    ntype = 6;
    types = "3S[40]";
  }
};
 
struct MQD_GETKEY {
  fstring<40> addr;
  fstring<40> name;
  fstring<40> value;
};
 
struct mqh_RETKEY : public MQ_HEADER {
  mqh_RETKEY ()
  {
    nslots = 30;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "RETKEY";
    ntype = 6;
    types = "3S[40]";
  }
};
 
struct MQD_RETKEY {
  fstring<40> addr;
  fstring<40> name;
  fstring<40> value;
};
 
struct mqh_RPKT : public MQ_HEADER {
  mqh_RPKT ()
  {
    nslots = 37;
    type = 'H';
    nhslots = 15;
    ndata = 3;
    info = 0;
    mode = 0;
    name = "RPKT";
    ntype = 15;
    types = "S[40]S[8]S[128]";
  }
};
 
struct MQD_RPKT {
  fstring<40> addr;
  fstring<8> func;
  fstring<128> data;
};
 
struct mqh_RERR : public MQ_HEADER {
  mqh_RERR ()
  {
    nslots = 47;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "RERR";
    ntype = 20;
    types = "S[80]S[40]S[8]S[128]";
  }
};
 
struct MQD_RERR {
  fstring<80> text;
  fstring<40> addr;
  fstring<8> func;
  fstring<128> data;
};
 
struct mqh_DISPCOLR : public MQ_HEADER {
  mqh_DISPCOLR ()
  {
    nslots = 22;
    type = 'H';
    nhslots = 15;
    ndata = 4;
    info = 0;
    mode = 0;
    name = "DISPCOLR";
    ntype = 7;
    types = "S[40]3L";
  }
};
 
struct MQD_DISPCOLR {
  fstring<40> label;
  int_4 icd;
  int_4 icv;
  int_4 blink;
};
 
#define L_mqh 120
#define L_mqd 8192
 
union MQ_DATA {
  MQD_MSGLOG		MSGLOG;
  MQD_XMSG		XMSG;
  MQD_TITLE		TITLE;
  MQD_MSGMASK		MSGMASK;
  MQD_MSGMASKINFO	MSGMASKINFO;
  MQD_SET		SET;
  MQD_SETL		SETL;
  MQD_SETD		SETD;
  MQD_QUERY		QUERY;
  MQD_COLOR		COLOR;
  MQD_COLORINFO		COLORINFO;
  MQD_COLORMAP		COLORMAP;
  MQD_COLORMAPINFO	COLORMAPINFO;
  MQD_TRACE		TRACE;
  MQD_OVERLAY		OVERLAY;
  MQD_DEOVERLAY		DEOVERLAY;
  MQD_TRIM		TRIM;
  MQD_CXMODE		CXMODE;
  MQD_CXMODEINFO	CXMODEINFO;
  MQD_ZOOM		ZOOM;
  MQD_ZOOMINFO		ZOOMINFO;
  MQD_UNZOOMINFO	UNZOOMINFO;
  MQD_PAN		PAN;
  MQD_PANRANGE		PANRANGE;
  MQD_PANINFO		PANINFO;
  MQD_PLOTINFO		PLOTINFO;
  MQD_MARKINFO		MARKINFO;
  MQD_MARK		MARK;
  MQD_ANNOTATE		ANNOTATE;
  MQD_BOXINFO		BOXINFO;
  MQD_BOXADD		BOXADD;
  MQD_BOXALTER		BOXALTER;
  MQD_POINTINFO		POINTINFO;
  MQD_POINTADD		POINTADD;
  MQD_POINTALTER	POINTALTER;
  MQD_XCNTRL		XCNTRL;
  MQD_XCTAG		XCTAG;
  MQD_XTODO		XTODO;
  MQD_HARDCOPY		HARDCOPY;
  MQD_COMMAND		COMMAND;
  MQD_COMMANDR		COMMANDR;
  MQD_CREPLY		CREPLY;
  MQD_NEWFILE		NEWFILE;
  MQD_NEWFILEINFO	NEWFILEINFO;
  MQD_MODIFYINFO	MODIFYINFO;
  MQD_MODIFY		MODIFY;
  MQD_SELECTINFO	SELECTINFO;
  MQD_SELECT		SELECT;
  MQD_LOOKUPINFO	LOOKUPINFO;
  MQD_LOOKUP		LOOKUP;
  MQD_HLITADD		HLITADD;
  MQD_HLITMOD		HLITMOD;
  MQD_HLITDEL		HLITDEL;
  MQD_FEDIT		FEDIT;
  MQD_FEDITINFO		FEDITINFO;
  MQD_XTEXT		XTEXT;
  MQD_XTEXTA		XTEXTA;
  MQD_XTEXTROW		XTEXTROW;
  MQD_XTEXTCLR		XTEXTCLR;
  MQD_XTEXTHDR		XTEXTHDR;
  MQD_XTXTRPOS		XTXTRPOS;
  MQD_T5REC		T5REC;
  MQD_T5TEXT		T5TEXT;
  MQD_T5LAYER		T5LAYER;
  MQD_ATMRTDAT		ATMRTDAT;
  MQD_ATMRTD8		ATMRTD8;
  MQD_ATMRTD16		ATMRTD16;
  MQD_ATMOVER		ATMOVER;
  MQD_ATMDOVER		ATMDOVER;
  MQD_NEWTRACE		NEWTRACE;
  MQD_DELTRACE		DELTRACE;
  MQD_THRESH		THRESH;
  MQD_TSTATE		TSTATE;
  MQD_YAXIS		YAXIS;
  MQD_TRNAME		TRNAME;
  MQD_TRNAME8		TRNAME8;
  MQD_TIMEADJ		TIMEADJ;
  MQD_ATMDIFF		ATMDIFF;
  MQD_SETKEY		SETKEY;
  MQD_ACKKEY		ACKKEY;
  MQD_GETKEY		GETKEY;
  MQD_RETKEY		RETKEY;
  MQD_RPKT		RPKT;
  MQD_RERR		RERR;
  MQD_DISPCOLR		DISPCOLR;
  int_1			bbuf[L_mqd];
  int_2			ibuf[L_mqd/2];
  int_4			lbuf[L_mqd/4];
  real_4		fbuf[L_mqd/4];
  real_8		dbuf[L_mqd/8];
  fstring<8>		abuf[L_mqd/8];
  fstring<L_mqd>	sbuf;
};
 
#define XM_QMESSDEF_HH_
#endif // XM_QMESSDEF_HH_
